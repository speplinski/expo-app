import numpy as np

from movement_detector.depth_info.simulation.visitor_simulation import VisitorSimulation


# simple simulation generated by Claude
class OakDSimulation:
    def __init__(self, horizontal_segments_count: int, vertical_segments_count: int):
        self.distances = np.zeros((vertical_segments_count, horizontal_segments_count))
        self.visitors = []
        self.speed_m_per_s = 0.3

        self.new_visitor_per_s_chance = 0.1
        self.visitor_change_movement_state_chance_per_s = 0.05
        self.visitor_movement_direction_change_chance_per_s = 0.01
        self.visitor_decide_to_leave_chance_per_s = 0.01
        self.two_cells_detection_margin = 0.2

    def get_distances(self) -> list[float]:
        return list(self.distances.flatten())

    def make_step(self, time_delta: float):
        if (np.random.random() < self.new_visitor_per_s_chance * time_delta) or (len(self.visitors) == 0):
            self.visitors.append(self._create_border_visitor())

        self.distances.fill(0)
        i = 0
        step_distance = self.speed_m_per_s * time_delta

        while i < len(self.visitors):
            visitor = self.visitors[i]

            if not visitor.is_leaving and np.random.random() < self.visitor_decide_to_leave_chance_per_s * time_delta:
                visitor.start_leaving(self.distances.shape)

            if not visitor.is_leaving:
                if np.random.random() < self.visitor_change_movement_state_chance_per_s * time_delta:
                    visitor.is_moving = not visitor.is_moving
                if visitor.is_moving and np.random.random() < self.visitor_movement_direction_change_chance_per_s * time_delta:
                    visitor.change_direction()

            visitor.move(step_distance)

            if visitor.is_out_of_bounds(self.distances.shape):
                self.visitors.pop(i)
                continue

            cy, cx = int(visitor.y), int(visitor.x)
            fraction_x = visitor.x - cx
            fraction_y = visitor.y - cy

            self.distances[cy, cx] = max(self.distances[cy, cx], visitor.height)

            if (fraction_x > 1 - self.two_cells_detection_margin) and (cx + 1 < self.distances.shape[1]):
                self.distances[cy, cx + 1] = max(self.distances[cy, cx + 1], visitor.height)
            elif (fraction_x < self.two_cells_detection_margin) and cx - 1 >= 0:
                self.distances[cy, cx - 1] = max(self.distances[cy, cx - 1], visitor.height)

            if (fraction_y > 1 - self.two_cells_detection_margin) and (cy + 1 < self.distances.shape[0]):
                self.distances[cy + 1, cx] = max(self.distances[cy + 1, cx], visitor.height)
            elif (fraction_y < self.two_cells_detection_margin) and (cy - 1 >= 0):
                self.distances[cy - 1, cx] = max(self.distances[cy - 1, cx], visitor.height)

            i += 1

    def _create_border_visitor(self) -> VisitorSimulation:
        height = np.random.uniform(0.8, 2.0)

        border = np.random.randint(0, 4)

        if border == 0:  # top
            x = np.random.uniform(0, self.distances.shape[1]-1)
            y = 0
            angle = np.random.uniform(-np.pi/4, np.pi/4)
        elif border == 1:  # right
            x = self.distances.shape[1]-1
            y = np.random.uniform(0, self.distances.shape[0]-1)
            angle = np.random.uniform(3*np.pi/4, 5*np.pi/4)
        elif border == 2:  # bottom
            x = np.random.uniform(0, self.distances.shape[1]-1)
            y = self.distances.shape[0]-1
            angle = np.random.uniform(3*np.pi/4, 5*np.pi/4)
        else:  # left
            x = 0
            y = np.random.uniform(0, self.distances.shape[0]-1)
            angle = np.random.uniform(-np.pi/4, np.pi/4)

        return VisitorSimulation(y, x, height, angle)
